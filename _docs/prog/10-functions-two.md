---
title: 8 &mdash; Продолжение функций, кортежи
---

# Продолжение функций, кортежи

## Содержание
1. [Кортежи - tuple](#кортежи)
1. [Возврат нескольких аргументов из функции](#возврат-нескольих-значений-из-функции)
1. [Именованные аргументы функции](#возврат-нескольих-значений-из-функции)
2. [**Домашнее задание**](#домашнее-задание)


## Кортежи

**Кортеж** - это неизменяемый и более быстрый аналог списка. Он защищает хранимые данные от непреднамеренных изменений. Называть его можно по-разному: кортеж, тапл, тюпл. Смысл от этого не меняется.

Что означает неизменяемый? То, что после его создания вы не сможете изменить его содержимое.

Посмотрим на примере

```python
>>> list_of_digits = [1, 2, 3]  # обычный список из 3 чисел
>>> list_of_digits[0] = 45  # Если захочется его изменить, то это легко сделать
>>> print(list_of_digits)
[45, 2, 3]
```

Повторим тот же самый код, но с кортежем

```python
>>> tuple_of_digits = (1, 2, 3,)
>>> tuple_of_digits[0] = 45
TypeError: 'tuple' object does not support item assignment
```

Ничего не получится.

Синтаксис определения кортежей

```python
>>> empty_tuple = () # Создание кортежа с помощью литерала
>>> yet_another_empty_tuple = tuple() # Создание кортежа с помощью встроенной функции
>>>
>>> some_tuple = (1, 2, ['a', 'b'], 4, 5,) # Инициализация кортежа
>>>
>>> hello_tuple = tuple('hello world') # Создание кортежа из итерируемого объекта, коим является строка
>>> print(hello_tuple)
('h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd')
```

При инициализации кортежа лучше завести привычку писать запятую после последнего элемента, иначе есть шанс ошибиться в случае кортежа, состоящего из одного элемента

```python
>>> int_not_tuple = (7) # Это математические скобки, не кортеж
>>> print(type(int_not_tuple))
<class 'int'>
>>> one_element_tuple = (7,) # Кортеж с одним элементом
>>> print(type(one_element_tuple))
<class 'tuple'>
```


Когда использовать кортежи? Когда нужно что-то неизменяемое. Рассмотрим пример

```python
months = (
    'Январь', 'Февраль', 'Март',
    'Апрель', 'Май', 'Июнь',
    'Июль', 'Август', 'Сентябрь',
    'Октябрь', 'Ноябрь', 'Декабрь'
)
```

У меня большие сомнения, что состав месяцев года когда-то изменится. Так что выбор тут очевиден - tuple!

## Возврат нескольих значений из функции

Tuple очень полезен, если из функции нужно вернуть несколько объектов. До этого мы всегда возвращали из функции только один объект. Например:

```python
def get_first_letter(word):
    return word[0]
```

А что делать, если нужно вернуть несколько аргументов?
В контрольной работе был частотный список слов русского словаря. Он имел вот такой вид:

```
а|союз|9808.61
абажур|сущ неод ед муж им|7.77
аббревиатура|сущ неод ед жен им|1.47
абвер|сущ неод ед муж им|1.22
аберрация|сущ неод ед жен им|3.0
абзац|сущ неод ед муж им|7.83
абитуриент|сущ одуш ед муж им|1.47
абонемент|сущ неод ед муж им|1.1
абонент|сущ одуш ед муж им|3.43
абориген|сущ одуш ед муж им|10.53
аборт|сущ неод ед муж им|9.79
абразив|сущ неод ед муж им|4.35
абракадабра|сущ неод ед жен им|1.22
...
```

Можно сильно упростить себе жизнь, если написать функцию, которая будет обрабатывать каждую строчку и сразу возвращать слово, его морфемы и частотность.

```python
def process_line(line):
    word, morph, ipm = line.split('|')
    morphs = morph.split()
    ipm = float(ipm)
    return word, morphs, ipm
```

И потом пользоваться этой функцией при обработки каждой строки вообще не заботясь о том, какие она операции выполняет.

```python
>>> line = 'абориген|сущ одуш ед муж им|10.53'
>>> process_line(line)
('абориген', ['сущ', 'одуш', 'ед', 'муж', 'им'], 10.53)
```

> Обратите внимание, что можно не ставить скобки в последней строке, питон и так знает, что если перечислено несколько значений через запятую после `return`, то нужно вернуть кортеж.


## Именованные аргументы функции

Мы уже несколько раз сталкивались с именованными аргументами, но не знали, что они так называются.

Все пользовались методом строк `split()`:

```python
>>> line = 'абориген|сущ одуш ед муж им|10.53'
>>> line.split('|', maxsplit=1)
['абориген', 'сущ одуш ед муж им|10.53']
```

В данном случае `maxsplit` — это именованный аргумент метода `split()`

Всеми любимая функция `print()` имеет сразу несколько именованных аргументов:

* `sep=' '`
* `end='\n'`
* и другие

Причем мы видим, что этим аргументам что-то присвоено — используется знак `=`.
На самом деле разработчики языка `Python` много думали и присвоили этим аргументам именно такие значения чтобы всем было удобно, но их можно задать явно. Например, если в конце строки мы хотим распечатать что-то экзотическое, то можно это сделать:

```python
>>> print('Привет, мир!', end='__end')
Привет, мир!__end
>>>
```

Если мы хотим при печати нескольих аргументов разделить их не пробелом, а чем-то еще, то можно написать вот так:

```python
>>> print('Привет', 'мой', 'родной', 'город', sep='==')
Привет==мой==родной==город
```

Как задавать именованные аргументы для своих функций?

```python
>>> def say_hello(name, status='Барон'):
...     print('Привет,', status, name)
...
>>> say_hello('Иван')
Привет, Барон Иван
>>> say_hello('Петр', status='Герцог')
Привет, Герцог Петр
```

**Важно!** Именованные аргументы всегда должны опеределяться после позиционных (обычных) аргументов:

```python
>>> def say_hello(status='Барон', name):
...     print('Привет,', status, name)
SyntaxError: non-default argument follows default argument
```

**Нельзя** определить именованный аргумент без назначения ему начального значения. Можно только задать специальное значение:

```python
>>> def say_hello(name, status=None):
...     if status is None:
...         print('Привет,', name)
...     else:
...         print('Добрый день,', status, name)
...
>>> say_hello('Петя')
Привет, Петя
>>> say_hello('Катя', status=None)
Привет, Катя
>>> say_hello('Смит', 'миссис')
Добрый день, миссис Смит
```

Именованные аргументы можно вызывать как позиционные в порядке их определения.

```python
>>> def print_line(symbol, length=10, start='|', end='|'):
...     print(start, symbol*length, end)
>>> print_line('-')
| ---------- |
>>> print_line('-', 20, '[', ']')
[ -------------------- ]
```

Большинство функций стандартной библиотеки python определены с использованием именованных аргументов, однако часто при вызове той или иной функции име не используется.

Этим нужно **пользоваться с осторожностью**. Если в функцию передается много параметров (больше 3), то лучше писать имя каждого параметра.


## Домашнее задание

{% include_relative hw/hw_10_base/README.md %}

